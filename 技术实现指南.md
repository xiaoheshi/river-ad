# 技术实现指南
## River-AD 优惠平台 - 独立开发者版本

## 🏗️ 核心架构概览（简化版）

### 技术栈决策（个人开发友好）
```
后端框架: Spring Boot 3.2.x (单体应用)
开发语言: Java 17 LTS
数据库: PostgreSQL 15+ (主库), Redis 7+ (缓存)
前端: React 18 + Next.js
部署: Docker Compose (简化部署)
监控: 基础日志 + Spring Actuator
```

### 单体架构设计（适合个人开发）
```
┌─────────────────────────────────────────────────────────┐
│                    Spring Boot Application              │
├─────────────────────────────────────────────────────────┤
│  Controller Layer  │  Service Layer  │  Repository Layer │
│  (REST API)        │  (业务逻辑)      │  (数据访问)        │
├─────────────────────────────────────────────────────────┤
│           数据层                                        │
│     PostgreSQL (主数据) │ Redis (缓存)                 │
└─────────────────────────────────────────────────────────┘
```

**为什么选择单体架构？**
- 简化部署和维护
- 降低系统复杂度
- 适合单人开发节奏
- 后期可拆分微服务

## 📊 数据库架构（简化版）

### 主数据库架构 (PostgreSQL)

```sql
-- 用户表 (简化版)
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    preferred_language VARCHAR(5) DEFAULT 'en',
    preferred_currency VARCHAR(3) DEFAULT 'USD',
    is_active BOOLEAN DEFAULT true,
    email_verified BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 优惠表 (核心表)
CREATE TABLE deals (
    id BIGSERIAL PRIMARY KEY,
    title_en VARCHAR(500) NOT NULL,
    title_zh VARCHAR(500),
    description_en TEXT,
    description_zh TEXT,
    
    original_price DECIMAL(10,2),
    sale_price DECIMAL(10,2),
    currency VARCHAR(3) DEFAULT 'USD',
    discount_percentage INTEGER,
    
    store_name VARCHAR(200) NOT NULL,
    category VARCHAR(100),
    
    affiliate_url TEXT NOT NULL,
    image_url TEXT,
    coupon_code VARCHAR(50),
    
    start_date TIMESTAMP,
    end_date TIMESTAMP,
    is_active BOOLEAN DEFAULT true,
    is_featured BOOLEAN DEFAULT false,
    
    click_count INTEGER DEFAULT 0,
    view_count INTEGER DEFAULT 0,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 点击跟踪表 (简化版)
CREATE TABLE clicks (
    id BIGSERIAL PRIMARY KEY,
    deal_id BIGINT REFERENCES deals(id),
    user_id BIGINT REFERENCES users(id),
    ip_address INET,
    user_agent TEXT,
    referrer TEXT,
    clicked_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    session_id VARCHAR(255)
);

-- 用户收藏表
CREATE TABLE favorites (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT REFERENCES users(id),
    deal_id BIGINT REFERENCES deals(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, deal_id)
);

-- 基础索引
CREATE INDEX idx_deals_active ON deals(is_active, created_at DESC);
CREATE INDEX idx_deals_category ON deals(category, is_active);
CREATE INDEX idx_deals_store ON deals(store_name, is_active);
CREATE INDEX idx_clicks_deal_date ON clicks(deal_id, clicked_at);
```

### 缓存策略 (Redis) - 简化版

```java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(15))
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()));

        return RedisCacheManager.builder(factory)
            .cacheDefaults(config)
            .build();
    }
}
```

## 🎯 核心服务实现

### 1. 优惠服务 (Deal Service)

```java
@RestController
@RequestMapping("/api/v1/deals")
@CrossOrigin(origins = "*")
public class DealController {

    @Autowired
    private DealService dealService;

    @GetMapping
    public ResponseEntity<PagedResponse<DealDto>> getDeals(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(required = false) String category,
            @RequestParam(required = false) String search,
            @RequestParam(defaultValue = "created_at") String sortBy,
            @RequestHeader(value = "Accept-Language", defaultValue = "en") String language) {
        
        PagedResponse<DealDto> deals = dealService.getDeals(
            PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, sortBy)),
            category, search, language
        );
        
        return ResponseEntity.ok(deals);
    }

    @GetMapping("/{id}")
    @Cacheable(value = "deals", key = "#id + '_' + #language")
    public ResponseEntity<DealDto> getDeal(
            @PathVariable Long id,
            @RequestHeader(value = "Accept-Language", defaultValue = "en") String language) {
        
        DealDto deal = dealService.getDeal(id, language);
        return ResponseEntity.ok(deal);
    }

    @PostMapping("/{id}/click")
    public ResponseEntity<ClickResponse> trackClick(
            @PathVariable Long id,
            HttpServletRequest request) {
        
        String trackingUrl = dealService.trackClick(id, request);
        return ResponseEntity.ok(new ClickResponse(trackingUrl));
    }
}

@Service
@Transactional
public class DealService {

    @Autowired
    private DealRepository dealRepository;
    
    @Autowired
    private ClickService clickService;

    public PagedResponse<DealDto> getDeals(Pageable pageable, String category, 
                                         String search, String language) {
        
        Specification<Deal> spec = Specification.where(null);
        spec = spec.and((root, query, cb) -> cb.equal(root.get("isActive"), true));
        
        if (StringUtils.hasText(category)) {
            spec = spec.and((root, query, cb) -> 
                cb.equal(root.get("category"), category));
        }
        
        if (StringUtils.hasText(search)) {
            spec = spec.and((root, query, cb) -> {
                String pattern = "%" + search.toLowerCase() + "%";
                return cb.or(
                    cb.like(cb.lower(root.get("titleEn")), pattern),
                    cb.like(cb.lower(root.get("titleZh")), pattern)
                );
            });
        }
        
        Page<Deal> deals = dealRepository.findAll(spec, pageable);
        
        return new PagedResponse<>(
            deals.getContent().stream()
                .map(deal -> convertToDto(deal, language))
                .collect(Collectors.toList()),
            deals.getNumber(),
            deals.getSize(),
            deals.getTotalElements(),
            deals.getTotalPages(),
            deals.isLast()
        );
    }

    public String trackClick(Long dealId, HttpServletRequest request) {
        Deal deal = dealRepository.findById(dealId)
            .orElseThrow(() -> new ResourceNotFoundException("Deal not found"));
        
        // 记录点击
        clickService.recordClick(dealId, request);
        
        // 更新点击计数
        dealRepository.incrementClickCount(dealId);
        
        // 返回跟踪URL
        return generateTrackingUrl(deal.getAffiliateUrl(), dealId);
    }

    private String generateTrackingUrl(String originalUrl, Long dealId) {
        try {
            URI uri = new URI(originalUrl);
            String query = uri.getQuery();
            
            StringBuilder trackingUrl = new StringBuilder(originalUrl);
            if (query == null || query.isEmpty()) {
                trackingUrl.append("?");
            } else {
                trackingUrl.append("&");
            }
            
            trackingUrl.append("utm_source=riverad")
                      .append("&utm_medium=affiliate")
                      .append("&utm_campaign=deals")
                      .append("&deal_id=").append(dealId);
            
            return trackingUrl.toString();
            
        } catch (URISyntaxException e) {
            log.error("Invalid URL: {}", originalUrl, e);
            return originalUrl;
        }
    }
}
```

### 2. 用户服务 (User Service) - 简化版

```java
@RestController
@RequestMapping("/api/v1/auth")
public class AuthController {

    @Autowired
    private UserService userService;

    @PostMapping("/register")
    public ResponseEntity<AuthResponse> register(@Valid @RequestBody RegisterRequest request) {
        AuthResponse response = userService.register(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @PostMapping("/login")
    public ResponseEntity<AuthResponse> login(@Valid @RequestBody LoginRequest request) {
        AuthResponse response = userService.authenticate(request);
        return ResponseEntity.ok(response);
    }
}

@Service
@Transactional
public class UserService {

    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Autowired
    private JwtTokenProvider jwtTokenProvider;

    public AuthResponse register(RegisterRequest request) {
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new BadRequestException("Email already in use");
        }

        User user = new User();
        user.setEmail(request.getEmail());
        user.setFirstName(request.getFirstName());
        user.setLastName(request.getLastName());
        user.setPasswordHash(passwordEncoder.encode(request.getPassword()));
        user.setPreferredLanguage(request.getPreferredLanguage());

        User savedUser = userRepository.save(user);
        String token = jwtTokenProvider.generateToken(savedUser.getEmail());

        return new AuthResponse(token, convertToDto(savedUser));
    }
}
```

### 3. 点击跟踪服务

```java
@Service
public class ClickService {

    @Autowired
    private ClickRepository clickRepository;

    public void recordClick(Long dealId, HttpServletRequest request) {
        Click click = new Click();
        click.setDealId(dealId);
        click.setIpAddress(getClientIP(request));
        click.setUserAgent(request.getHeader("User-Agent"));
        click.setReferrer(request.getHeader("Referer"));
        click.setSessionId(request.getSession().getId());
        click.setClickedAt(LocalDateTime.now());
        
        clickRepository.save(click);
    }

    private String getClientIP(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0].trim();
        }
        return request.getRemoteAddr();
    }
}
```

## 🌍 国际化 (i18n) 实现

```java
@Configuration
public class I18nConfig {

    @Bean
    public LocaleResolver localeResolver() {
        AcceptHeaderLocaleResolver resolver = new AcceptHeaderLocaleResolver();
        resolver.setSupportedLocales(Arrays.asList(Locale.US, Locale.SIMPLIFIED_CHINESE));
        resolver.setDefaultLocale(Locale.US);
        return resolver;
    }

    @Bean
    public MessageSource messageSource() {
        ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
        messageSource.setBasenames("messages");
        messageSource.setDefaultEncoding("UTF-8");
        messageSource.setUseCodeAsDefaultMessage(true);
        return messageSource;
    }
}
```

## 🚀 性能优化（实用版）

### 1. 数据库优化

```yaml
# application.yml
spring:
  datasource:
    hikari:
      maximum-pool-size: 10
      minimum-idle: 2
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
  
  jpa:
    hibernate:
      ddl-auto: validate
    properties:
      hibernate:
        jdbc:
          batch_size: 20
        order_inserts: true
        order_updates: true
```

### 2. 缓存策略

```java
@Component
public class DealCacheService {

    @Cacheable(value = "deals", key = "#dealId + '_' + #language")
    public DealDto getCachedDeal(Long dealId, String language) {
        return dealService.getDeal(dealId, language);
    }

    @Cacheable(value = "featured_deals", key = "#language")
    public List<DealDto> getFeaturedDeals(String language) {
        return dealService.getFeaturedDeals(language);
    }

    @CacheEvict(value = {"deals", "featured_deals"}, allEntries = true)
    public void clearAllCache() {
        // 清除所有缓存
    }
}
```

## 📊 监控配置（简化版）

```java
@Configuration
public class MonitoringConfig {

    @Bean
    public MeterRegistry meterRegistry() {
        return new SimpleMeterRegistry();
    }

    @EventListener
    public void handleDealClick(DealClickEvent event) {
        Metrics.counter("deal.clicks", "deal_id", event.getDealId().toString()).increment();
    }
}

// 健康检查
@Component
public class CustomHealthIndicator implements HealthIndicator {

    @Autowired
    private DealRepository dealRepository;

    @Override
    public Health health() {
        try {
            long count = dealRepository.count();
            if (count > 0) {
                return Health.up()
                    .withDetail("deals.count", count)
                    .build();
            } else {
                return Health.down()
                    .withDetail("deals.count", 0)
                    .build();
            }
        } catch (Exception e) {
            return Health.down(e).build();
        }
    }
}
```

## 🔒 安全配置（简化版）

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(10);
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf().disable()
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/api/v1/auth/**").permitAll()
                .requestMatchers("/api/v1/deals/**").permitAll()
                .requestMatchers("/actuator/health").permitAll()
                .anyRequest().authenticated()
            )
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);

        return http.build();
    }
}
```

## 🐳 Docker 部署配置（简化版）

### Dockerfile
```dockerfile
FROM openjdk:17-jdk-slim

WORKDIR /app

COPY target/river-ad-*.jar app.jar

HEALTHCHECK --interval=30s --timeout=3s --start-period=60s --retries=3 \
  CMD curl -f http://localhost:8080/actuator/health || exit 1

ENTRYPOINT ["java", "-jar", "/app/app.jar"]

EXPOSE 8080
```

### docker-compose.yml
```yaml
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    container_name: riverad-postgres
    environment:
      POSTGRES_DB: riverad
      POSTGRES_USER: riverad
      POSTGRES_PASSWORD: ${DB_PASSWORD:-riverad123}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    networks:
      - riverad-network

  redis:
    image: redis:7-alpine
    container_name: riverad-redis
    ports:
      - "6379:6379"
    networks:
      - riverad-network

  backend:
    build: .
    container_name: riverad-backend
    depends_on:
      - postgres
      - redis
    environment:
      SPRING_PROFILES_ACTIVE: production
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/riverad
      SPRING_DATASOURCE_USERNAME: riverad
      SPRING_DATASOURCE_PASSWORD: ${DB_PASSWORD:-riverad123}
      SPRING_REDIS_HOST: redis
      JWT_SECRET: ${JWT_SECRET:-your-secret-key}
    ports:
      - "8080:8080"
    networks:
      - riverad-network
    restart: unless-stopped

volumes:
  postgres_data:

networks:
  riverad-network:
    driver: bridge
```

## 🛠️ 开发工具配置

### application.yml (开发环境)
```yaml
spring:
  profiles:
    active: development
  
  datasource:
    url: jdbc:postgresql://localhost:5432/riverad
    username: riverad
    password: riverad123
  
  jpa:
    show-sql: true
    hibernate:
      ddl-auto: update
  
  redis:
    host: localhost
    port: 6379
  
  cache:
    type: redis

server:
  port: 8080

logging:
  level:
    com.riverad: DEBUG
    org.springframework.web: DEBUG
```

## 📝 API文档配置

```java
@Configuration
@EnableOpenApi
public class OpenApiConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
            .info(new Info()
                .title("River-AD API")
                .version("1.0")
                .description("海外优惠平台API文档"))
            .servers(List.of(
                new Server().url("http://localhost:8080").description("开发环境"),
                new Server().url("https://api.riverad.com").description("生产环境")
            ));
    }
}
```

## 🚀 部署脚本

```bash
#!/bin/bash
# deploy.sh

echo "🚀 开始部署 River-AD..."

# 构建应用
echo "📦 构建应用..."
./mvnw clean package -DskipTests

# 构建并启动服务
echo "🐳 启动服务..."
docker-compose down
docker-compose up --build -d

# 等待服务启动
echo "⏳ 等待服务启动..."
sleep 30

# 健康检查
echo "🏥 进行健康检查..."
curl -f http://localhost:8080/actuator/health

echo "✅ 部署完成！"
echo "🌐 应用访问地址: http://localhost:8080"
echo "📊 监控地址: http://localhost:8080/actuator"
```

---

**个人开发者技术建议**:

1. **从简单开始**: 单体架构，避免过度工程化
2. **逐步优化**: 先实现功能，再优化性能
3. **合理缓存**: 只缓存真正需要的数据
4. **监控要点**: 关注核心指标，避免监控过载
5. **安全第一**: 基础安全配置必须到位
6. **文档齐全**: API文档和部署文档要完整

*记住：最好的架构是能够快速交付价值的架构！*